import { visit } from 'unist-util-visit';
import { toString } from 'hast-util-to-string';

const InlineCodeHandlers = {
  "tailing-curly-colon": (_tree, node) => {
    const raw = toString(node);
    const match = raw.match(/(.+)\{:([\w-]+)\}$/);
    if (!match)
      return;
    return {
      type: "inline",
      code: match[1] ?? raw,
      lang: match.at(2)
    };
  }
};
const languagePrefix$1 = "language-";
const PreHandler = (_tree, node) => {
  const head = node.children[0];
  if (!head || head.type !== "element" || head.tagName !== "code" || !head.properties) {
    return;
  }
  const classes = head.properties.className;
  const languageClass = Array.isArray(classes) ? classes.find(
    (d) => typeof d === "string" && d.startsWith(languagePrefix$1)
  ) : void 0;
  return {
    type: "pre",
    lang: typeof languageClass === "string" ? languageClass.slice(languagePrefix$1.length) : void 0,
    code: toString(head),
    meta: head.data?.meta ?? head.properties.metastring?.toString() ?? ""
  };
};

const languagePrefix = "language-";
function rehypeShikiFromHighlighter(highlighter, options) {
  const {
    addLanguageClass = false,
    parseMetaString,
    cache,
    defaultLanguage,
    fallbackLanguage,
    onError,
    stripEndNewline = true,
    inline = false,
    lazy = false,
    ...rest
  } = options;
  function highlight(lang, code, metaString = "", meta = {}) {
    const cacheKey = `${lang}:${metaString}:${code}`;
    const cachedValue = cache?.get(cacheKey);
    if (cachedValue) {
      return cachedValue;
    }
    const codeOptions = {
      ...rest,
      lang,
      meta: {
        ...rest.meta,
        ...meta,
        __raw: metaString
      }
    };
    if (addLanguageClass) {
      codeOptions.transformers = [
        ...codeOptions.transformers ?? [],
        {
          name: "rehype-shiki:code-language-class",
          code(node) {
            this.addClassToHast(node, `${languagePrefix}${lang}`);
            return node;
          }
        }
      ];
    }
    if (stripEndNewline && code.endsWith("\n"))
      code = code.slice(0, -1);
    try {
      const fragment = highlighter.codeToHast(code, codeOptions);
      cache?.set(cacheKey, fragment);
      return fragment;
    } catch (error) {
      if (onError)
        onError(error);
      else
        throw error;
    }
  }
  return (tree) => {
    const languageQueue = [];
    const queue = [];
    function getLanguage(lang) {
      if (!lang)
        return defaultLanguage;
      if (highlighter.getLoadedLanguages().includes(lang))
        return lang;
      if (lazy) {
        languageQueue.push(lang);
        return lang;
      }
      if (fallbackLanguage)
        return fallbackLanguage;
    }
    visit(tree, "element", (node, index, parent) => {
      let handler;
      if (!parent || index == null)
        return;
      if (node.tagName === "pre") {
        handler = PreHandler;
      }
      if (node.tagName === "code" && inline) {
        handler = InlineCodeHandlers[inline];
      }
      if (!handler)
        return;
      const res = handler(tree, node);
      if (!res)
        return;
      const lang = getLanguage(res.lang);
      if (!lang)
        return;
      const processNode = () => {
        const meta = res.meta ? parseMetaString?.(res.meta, node, tree) : void 0;
        const fragment = highlight(lang, res.code, res.meta, meta ?? {});
        if (!fragment)
          return;
        if (res.type === "inline") {
          const head = fragment.children[0];
          if (head.type === "element" && head.tagName === "pre") {
            head.tagName = "span";
          }
        }
        parent.children.splice(index, 1, ...fragment.children);
      };
      if (lazy)
        queue.push(processNode);
      else
        processNode();
      return "skip";
    });
    if (lazy) {
      return highlighter.loadLanguage(...languageQueue).then(() => {
        queue.forEach((fn) => fn());
      });
    }
  };
}

export { rehypeShikiFromHighlighter as default };
